import os
import json
import requests
import logging
from datetime import datetime
from dotenv import load_dotenv
from time import sleep
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('crypto_analyzer.log', encoding='utf-8')
    ])
logger = logging.getLogger(__name__)

# –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
load_dotenv()
API_KEY = os.getenv('CRYPTORANK_API_KEY')
TG_TOKEN = os.getenv('TELEGRAM_TOKEN')
DB_FILE = 'crypto_analyzer_db.json'  # –ï–¥–∏–Ω—ã–π —Ñ–∞–π–ª –¥–ª—è –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö
BASE_URL = 'https://api.cryptorank.io/v2'


class CryptoAnalyzer:

    def __init__(self):
        self.db_file = DB_FILE
        self.data = self._load_or_create_db()
        self.session = requests.Session()
        self.session.headers.update({
            'Accept': 'application/json',
            'X-Api-Key': API_KEY
        })

    def _load_or_create_db(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
        if os.path.exists(self.db_file):
            with open(self.db_file, 'r', encoding='utf-8') as f:
                return json.load(f)

        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        new_db = {
            'projects': {},
            'categories': {},
            'tags': {},
            'metadata': {
                'last_update': None,
                'total_projects': 0,
                'api_credits_used': 0,
                'last_category_update': None
            }
        }
        self._save_db(new_db)
        return new_db

    def _save_db(self, data=None):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
        with open(self.db_file, 'w', encoding='utf-8') as f:
            json.dump(data or self.data, f, indent=2, ensure_ascii=False)

    def _make_api_request(self, endpoint, params=None):
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ API –∑–∞–ø—Ä–æ—Å–∞"""
        try:
            response = self.session.get(f"{BASE_URL}/{endpoint}",
                                        params=params,
                                        timeout=30)

            if response.status_code == 200:
                data = response.json()
                credits = data.get('status', {}).get('usedCredits', 1)
                self.data['metadata']['api_credits_used'] += credits
                return {'success': True, 'data': data}
            else:
                return {
                    'success': False,
                    'error': f"HTTP {response.status_code}",
                    'message': response.text
                }
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def fetch_all_categories(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π"""
        logger.info("–ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π...")
        result = self._make_api_request("currencies/categories")

        if not result['success']:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π: {result['error']}")
            return []

        categories = result['data'].get('data', [])
        self.data['categories'] = {cat['id']: cat for cat in categories}
        self.data['metadata']['last_category_update'] = datetime.now(
        ).isoformat()
        self._save_db()

        logger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(categories)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π")
        return categories

    def fetch_projects_by_category(self, category_id):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–æ–≤ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏"""
        params = {
            'limit': 100,
            'offset': 0,
            'sortBy': 'rank',
            'sortDirection': 'ASC',
            'categoryId': category_id
        }

        all_projects = []
        while True:
            result = self._make_api_request("currencies", params)

            if not result['success']:
                logger.error(
                    f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–µ–∫—Ç–æ–≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category_id}: {result['error']}"
                )
                break

            projects = result['data'].get('data', [])
            if not projects:
                break

            all_projects.extend(projects)
            params['offset'] += len(projects)
            logger.info(
                f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è {category_id}: –∑–∞–≥—Ä—É–∂–µ–Ω–æ {len(projects)} –ø—Ä–æ–µ–∫—Ç–æ–≤. –í—Å–µ–≥–æ: {len(all_projects)}"
            )

            if len(projects) < params['limit']:
                break

        return all_projects

    def update_all_projects(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º"""
        logger.info("–ù–∞—á–∞–ª–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–æ–≤")

        # –°–Ω–∞—á–∞–ª–∞ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
        categories = self.fetch_all_categories()
        if not categories:
            return False

        total_new = 0

        for category in categories:
            category_id = category['id']
            logger.info(
                f"–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: {category['name']} (ID: {category_id})")

            projects = self.fetch_projects_by_category(category_id)
            new_in_category = 0

            for project in projects:
                project_id = str(project['id'])

                if project_id not in self.data['projects']:
                    self.data['projects'][project_id] = {
                        'id': project.get('id'),
                        'name': project.get('name'),
                        'symbol': project.get('symbol'),
                        'price': project.get('price'),
                        'marketCap': project.get('marketCap'),
                        'volume24h': project.get('volume24h'),
                        'categoryId': project.get('categoryId'),
                        'url':
                        f"https://cryptorank.io/price/{project.get('key', '')}",
                        'added': datetime.now().strftime('%Y-%m-%d %H:%M'),
                        'last_updated': datetime.now().isoformat()
                    }
                    new_in_category += 1
                else:
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø—Ä–æ–µ–∫—Ç
                    self.data['projects'][project_id].update({
                        'price':
                        project.get('price'),
                        'marketCap':
                        project.get('marketCap'),
                        'volume24h':
                        project.get('volume24h'),
                        'last_updated':
                        datetime.now().isoformat()
                    })

            logger.info(
                f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è {category['name']}: –¥–æ–±–∞–≤–ª–µ–Ω–æ {new_in_category} –Ω–æ–≤—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤"
            )
            total_new += new_in_category
            sleep(1)  # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏

        # –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
        self.data['metadata'].update({
            'last_update':
            datetime.now().isoformat(),
            'total_projects':
            len(self.data['projects']),
            'new_projects':
            total_new
        })

        self._save_db()
        logger.info(
            f"–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –í—Å–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–æ–≤: {len(self.data['projects'])}, –Ω–æ–≤—ã—Ö: {total_new}"
        )
        return True

    def get_stats(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        return {
            'total_projects': len(self.data['projects']),
            'total_categories': len(self.data['categories']),
            'last_update': self.data['metadata'].get('last_update', '–Ω–∏–∫–æ–≥–¥–∞'),
            'api_credits_used':
            self.data['metadata'].get('api_credits_used', 0),
            'new_projects': self.data['metadata'].get('new_projects', 0)
        }

    def get_recent_projects(self, count=10):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤"""
        projects = list(self.data['projects'].values())
        return sorted(projects, key=lambda x: x.get('added', ''),
                      reverse=True)[:count]


# Telegram Bot Handlers
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üîç Crypto Analyzer Bot\n\n"
                                    "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                                    "/update - –û–±–Ω–æ–≤–∏—Ç—å –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö\n"
                                    "/stats - –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É\n"
                                    "/projects - –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç—ã")


async def update_db(update: Update, context: ContextTypes.DEFAULT_TYPE):
    analyzer = CryptoAnalyzer()
    msg = await update.message.reply_text("üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö...")

    try:
        if analyzer.update_all_projects():
            stats = analyzer.get_stats()
            response = (
                f"‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∞\n"
                f"–í—Å–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–æ–≤: {stats['total_projects']}\n"
                f"–ù–æ–≤—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤: {stats['new_projects']}\n"
                f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤ API: {stats['api_credits_used']}\n"
                f"–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {stats['last_update']}")
            await msg.edit_text(response)
        else:
            await msg.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö")
    except Exception as e:
        await msg.edit_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏: {str(e)}")


async def show_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    analyzer = CryptoAnalyzer()
    stats = analyzer.get_stats()

    await update.message.reply_text(
        f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö:\n"
        f"‚Ä¢ –í—Å–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–æ–≤: {stats['total_projects']}\n"
        f"‚Ä¢ –í—Å–µ–≥–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–π: {stats['total_categories']}\n"
        f"‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {stats['last_update']}\n"
        f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤ API: {stats['api_credits_used']}\n"
        f"‚Ä¢ –§–∞–π–ª –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {DB_FILE}")


async def show_projects(update: Update, context: ContextTypes.DEFAULT_TYPE):
    analyzer = CryptoAnalyzer()
    projects = analyzer.get_recent_projects(10)

    if not projects:
        await update.message.reply_text("–í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç –ø—Ä–æ–µ–∫—Ç–æ–≤")
        return

    message = "üìã –ü–æ—Å–ª–µ–¥–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ –ø—Ä–æ–µ–∫—Ç—ã:\n\n" + "\n".join(
        f"{i}. {p['name']} ({p['symbol']}) - ${p.get('price', 'N/A')}\n"
        f"   –ö–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è: ${p.get('marketCap', 'N/A'):,}\n"
        f"   –î–æ–±–∞–≤–ª–µ–Ω: {p['added']}\n"
        f"   {p['url']}" for i, p in enumerate(projects, 1))

    await update.message.reply_text(message[:4000])  # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ Telegram


def run_bot():
    """–ó–∞–ø—É—Å–∫ Telegram –±–æ—Ç–∞"""
    try:
        logger.info("–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞...")
        app = ApplicationBuilder().token(TG_TOKEN).build()

        app.add_handler(CommandHandler("start", start))
        app.add_handler(CommandHandler("update", update_db))
        app.add_handler(CommandHandler("stats", show_stats))
        app.add_handler(CommandHandler("projects", show_projects))

        logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ")
        app.run_polling()

    except Exception as e:
        logger.critical(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞: {str(e)}")
        raise


if __name__ == '__main__':
    run_bot()
